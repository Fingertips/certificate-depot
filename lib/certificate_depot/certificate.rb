class CertificateDepot
  # Represents an OpenSSL certificate. TLS/SSL certificates are a rather
  # complicated mix of several standards. If you're not familiar with TLS
  # certificates, it might help to start by reading the Wikipedia article on
  # the subject: http://en.wikipedia.org/wiki/Public_key_certificate.
  #
  #   certificate = CertificateDepot::Certificate.from_file('server.pem')
  #   certificate.issuer
  class Certificate
    # Our generated certificates are valid for 10 years by default.
    DEFAULT_VALIDITY_PERIOD = 3600 * 24 * 365 * 10
    # We create version 3 certificates. Count starts a 0 so 2 is actually 3.
    X509v3 = 2
    
    # Used to map programmer readable attributes to X509 subject attributes.
    ATTRIBUTE_MAP = {
      :common_name              => 'CN',
      :locality_name            => 'L',
      :state_or_province_name   => 'ST',
      :organization             => 'O',
      :organizational_unit_name => 'OU',
      :country_name             => 'C',
      :street_address           => 'STREET',
      :domain_component         => 'DC',
      :user_id                  => 'UID',
      :email_address            => 'emailAddress'
    }
    
    attr_accessor :certificate
    
    # Creates a new certificate instance. The certificate argument should be
    # a OpenSSL::X509::Certificate instance.
    def initialize(certificate=nil)
      @certificate = certificate
    end
    
    # Generates a new certificate. Possible and compulsory attributes depend
    # on the type of certificate.
    #
    # === Client certificate
    #
    # Client certificates are used to authenticate a client to a server. They
    # are generated by setting the <tt>:type</tt> attribute to
    # <tt>:client</tt>.
    #
    # ==== Compulsory
    #
    # * <tt>:ca_certificate</tt> - A CertificateDepot::Certificate instance
    #   representing the Certification Authority.
    # * <tt>:serial_number</tt> - The serial number to store in the
    #   certificate. This number should be unique for certificates issued
    #   by the CA.
    # * <tt>:public_key</tt> - A public key which is the sister key of the
    #   private key used by the client.
    #
    # ==== Options
    #
    # You can choose to either supply an instance of OpenSSL::X509::Name as
    # the <tt>:subject</tt> attribute or supply any of the attributes listed
    # in ATTRIBUTE_MAP to generate the subject name. For example:
    #
    #   generate(:common_name => 'John Doe', :email_address => 'john@example.com')
    #
    # === Server certificate
    #
    # Server certificates are used to authenticate a server to a client and
    # set up a secure socket. They are generated by setting the <tt>:type</tt>
    # attribute to <tt>:server</tt>.
    #
    # ==== Compulsory
    #
    # * <tt>:ca_certificate</tt> - A CertificateDepot::Certificate instance
    #   representing the Certification Authority.
    # * <tt>:serial_number</tt> - The serial number to store in the
    #   certificate. This number should be unique for certificates issued
    #   by the CA.
    # * <tt>:public_key</tt> - A public key which is the sister key of the
    #   private key used by the client.
    # * <tt>:common_name</tt> - The common name has to match the hostname used
    #   for the server. It has to be either a complete match or a wildcard
    #   match. So <tt>*.example.com</tt> will match <tt>www.example.com</tt>
    #   and <tt>mail.example.com</tt> but <tt>example.com</tt> will only match
    #   <tt>example.com</tt>.
    #
    # ==== Options
    #
    # If you want to supply an instance of OpenSSL::X509::Name as the
    # <tt>:subject</tt> of the certificate, please make sure you set the CN
    # attribute to the correct value of the certificate will be worthless.
    #
    # You can choose to set any of the other X509 attributes as found in the
    # ATTRIBUTE_MAP, but none of the are strictly necessary.
    #
    # === Certification Authority certificate
    #
    # CA certificates are used to sign all certificates issued by the CA. They
    # are generated by setting the <tt>:type</tt> to <tt>:ca</tt>.
    #
    # ==== Options
    #
    # You can choose to either supply an instance of OpenSSL::X509::Name as
    # the <tt>:subject</tt> attribute or supply any of the attributes listed
    # in ATTRIBUTE_MAP to generate the subject name. For example:
    #
    #   subject = OpenSSL::X509::Name.new
    #   subject.add_entry('CN', 'Certificate Depot CA')
    #   generate(:subject => subject)
    #
    #   generate(:common_name => 'Certificate Depot CA')
    #
    # Note that this name will be used for both the subject and issuer
    # field in the certificate because it's a so-called
    # sign-signed certificate.
    def generate(attributes={})
      from         = Time.now
      to           = Time.now + DEFAULT_VALIDITY_PERIOD
      
      name         =  attributes[:subject] || OpenSSL::X509::Name.new
      ATTRIBUTE_MAP.each do |internal, x509_attribute|
        name.add_entry(x509_attribute, attributes[internal]) if attributes[internal]
      end
      
      case attributes[:type]
      when :client, :server
        issuer = attributes[:ca_certificate].subject
        serial = attributes[:serial_number]
      when :ca
        issuer = name
        serial = 0
      else
        raise ArgumentError, "Unknown certificate type #{attributes[:type]}, please specify either :client, :server, or :ca"
      end
      
      raise ArgumentError, "Please supply a serial number for the certificate to generate" unless serial
      
      @certificate = OpenSSL::X509::Certificate.new
      @certificate.subject    = name
      @certificate.issuer     = issuer
      @certificate.not_before = from
      @certificate.not_after  = to
      @certificate.version    = X509v3
      @certificate.public_key = attributes[:public_key]
      @certificate.serial     = serial
      
      extensions = []
      factory = OpenSSL::X509::ExtensionFactory.new
      factory.subject_certificate = @certificate
      
      case attributes[:type]
      when :server
        factory.issuer_certificate = attributes[:ca_certificate].certificate
        extensions << factory.create_extension('basicConstraints', 'CA:FALSE', true)
        extensions << factory.create_extension('keyUsage', 'digitalSignature,keyEncipherment')
        extensions << factory.create_extension('extendedKeyUsage', 'serverAuth,clientAuth,emailProtection')
      when :client
        factory.issuer_certificate = attributes[:ca_certificate].certificate
        extensions << factory.create_extension('basicConstraints', 'CA:FALSE', true)
        extensions << factory.create_extension('keyUsage', 'nonRepudiation,digitalSignature,keyEncipherment')
        extensions << factory.create_extension('extendedKeyUsage', 'clientAuth')
      when :ca
        factory.issuer_certificate = @certificate
        extensions << factory.create_extension('basicConstraints', 'CA:TRUE', true)
        extensions << factory.create_extension('keyUsage', 'cRLSign,keyCertSign')
      end
      extensions << factory.create_extension('subjectKeyIdentifier', 'hash')
      extensions << factory.create_extension('authorityKeyIdentifier', 'keyid,issuer:always')
      
      @certificate.extensions = extensions
      
      if attributes[:private_key]
        @certificate.sign(attributes[:private_key], OpenSSL::Digest::SHA1.new)
      end
      
      @certificate
    end
    
    # Writes the certificate to file. The path should be a filename pointing to
    # an existing directory. Note that this will overwrite files without
    # asking.
    def write_to(path)
      File.open(path, 'w') { |file| file.write(@certificate.to_pem) }
    end
    
    # Returns the public key in the certificate.
    def public_key
      @certificate.public_key
    end
    
    # Returns the issuer for the certificate.
    def issuer
      @certificate.issuer
    end
    
    # Returns the subject of the certificate.
    def subject
      @certificate.subject
    end
    
    # Returns the serial number of the certificate.
    def serial_number
      @certificate.serial
    end
    
    # Used to support easy querying of subject attributes. See ATTRIBUTE_MAP
    # for a complete list of supported attributes.
    #
    #   certificate.common_name #=> '*.example.com'
    def method_missing(method, *attributes, &block)
      if x509_attribute = ATTRIBUTE_MAP[method.to_sym]
        self[x509_attribute]
      else
        super
      end
    end
    
    # Used to support easy querying of subject attributes. See ATTRIBUTE_MAP
    # for a complete list of supported attributes.
    #
    #   certificate['common_name'] #=> '*.example.com'
    def [](key)
      @certificate.subject.to_a.each do |name, value, type|
        return value if name == key
      end; nil
    end
    
    # Shortcut for CertificateDepot::Certificate#generate. See this method for
    # more details.
    def self.generate(attributes={})
      certificate = new
      certificate.generate(attributes)
      certificate
    end
    
    # Instantiates a new instance using certificate data read from file.
    def self.from_file(path)
      new(OpenSSL::X509::Certificate.new(File.read(path)))
    end
  end
end